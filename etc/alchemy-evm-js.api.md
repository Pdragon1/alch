## API Report File for "alchemy-evm-js"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { providers } from 'ethers';
import { TransactionReceipt } from '@ethersproject/abstract-provider';

// @public
export class Alchemy {
    // (undocumented)
    readonly apiKey: string;
    getProvider(): providers.AlchemyProvider;
    // (undocumented)
    readonly maxRetries: number;
    // (undocumented)
    network: Network;
    setNetwork(network: Network): void;
}

// @public
export interface AlchemyConfig {
    apiKey?: string;
    maxRetries?: number;
    network?: Network;
}

// @public (undocumented)
export enum AssetTransfersCategory {
    // (undocumented)
    ERC1155 = "erc1155",
    // (undocumented)
    ERC20 = "erc20",
    // (undocumented)
    ERC721 = "erc721",
    // (undocumented)
    EXTERNAL = "external",
    // (undocumented)
    INTERNAL = "internal",
    // (undocumented)
    SPECIALNFT = "specialnft",
    // (undocumented)
    TOKEN = "token"
}

// @public (undocumented)
export enum AssetTransfersOrder {
    // (undocumented)
    ASCENDING = "asc",
    // (undocumented)
    DESCENDING = "desc"
}

// @public (undocumented)
export interface AssetTransfersParams {
    // (undocumented)
    category?: AssetTransfersCategory[];
    // (undocumented)
    contractAddresses?: string[];
    // (undocumented)
    excludeZeroValue?: boolean;
    // (undocumented)
    fromAddress?: string;
    // (undocumented)
    fromBlock?: string;
    // (undocumented)
    maxCount?: number;
    // (undocumented)
    order?: AssetTransfersOrder;
    // (undocumented)
    pageKey?: string;
    // (undocumented)
    toAddress?: string;
    // (undocumented)
    toBlock?: string;
}

// @public (undocumented)
export interface AssetTransfersResponse {
    // (undocumented)
    pageKey?: string;
    // (undocumented)
    transfers: AssetTransfersResult[];
}

// @public (undocumented)
export interface AssetTransfersResult {
    // (undocumented)
    asset: string | null;
    // (undocumented)
    blockNum: string;
    // (undocumented)
    category: AssetTransfersCategory;
    // (undocumented)
    erc1155Metadata: ERC1155Metadata[] | null;
    // (undocumented)
    erc721TokenId: string | null;
    // (undocumented)
    from: string;
    // (undocumented)
    hash: string;
    // (undocumented)
    rawContract: RawContract;
    // (undocumented)
    to: string | null;
    // (undocumented)
    tokenId: string | null;
    // (undocumented)
    value: number | null;
}

// @public
export class BaseNft {
    protected constructor(address: string,
    tokenId: string,
    tokenType: NftTokenType);
    // (undocumented)
    readonly contract: NftContract;
    readonly tokenId: string;
    readonly tokenType: NftTokenType;
}

// @beta
export function checkNftOwnership(alchemy: Alchemy, owner: string, contractAddresses: string[]): Promise<boolean>;

// @public
export interface CollectionBaseNftsResponse {
    nfts: BaseNft[];
    pageKey?: string;
}

// @public
export interface CollectionNftsResponse {
    nfts: Nft[];
    pageKey?: string;
}

// @public
export interface DeployResult {
    readonly blockNumber: number;
    readonly deployerAddress?: string;
}

// @public (undocumented)
export interface ERC1155Metadata {
    // (undocumented)
    tokenId: string;
    // (undocumented)
    value: string;
}

// @beta
export function findContractDeployer(alchemy: Alchemy, contractAddress: string): Promise<DeployResult>;

// @public
export function fromHex(hexString: string): number;

// @public (undocumented)
export function getAssetTransfers(alchemy: Alchemy, params: AssetTransfersParams): Promise<AssetTransfersResponse>;

// @public
export interface GetBaseNftsForCollectionOptions {
    omitMetadata: false;
    pageKey?: string;
}

// @public
export interface GetBaseNftsForOwnerOptions {
    contractAddresses?: string[];
    // Warning: (ae-incompatible-release-tags) The symbol "excludeFilters" is marked as @public, but its signature references "NftExcludeFilters" which is marked as @beta
    excludeFilters?: NftExcludeFilters[];
    omitMetadata: true;
    pageKey?: string;
}

// @public
export function getNftMetadata(alchemy: Alchemy, baseNft: BaseNft): Promise<Nft>;

// @public
export function getNftMetadata(alchemy: Alchemy, contractAddress: string, tokenId: number | string, tokenType?: NftTokenType): Promise<Nft>;

// @beta
export function getNftsForCollection(alchemy: Alchemy, contractAddress: string, options?: GetBaseNftsForCollectionOptions): Promise<CollectionBaseNftsResponse>;

// @beta
export function getNftsForCollection(alchemy: Alchemy, contractAddress: string, options?: GetNftsForCollectionOptions): Promise<CollectionNftsResponse>;

// @beta
export function getNftsForCollectionIterator(alchemy: Alchemy, contractAddress: string, options: GetBaseNftsForCollectionOptions): AsyncIterable<BaseNft>;

// @beta
export function getNftsForCollectionIterator(alchemy: Alchemy, contractAddress: string, options: GetNftsForCollectionOptions): AsyncIterable<Nft>;

// @public
export interface GetNftsForCollectionOptions {
    omitMetadata?: boolean;
    pageKey?: string;
}

// @public
export function getNftsForOwner(alchemy: Alchemy, owner: string, options?: GetBaseNftsForOwnerOptions): Promise<OwnedBaseNftsResponse>;

// @public
export function getNftsForOwner(alchemy: Alchemy, owner: string, options?: GetNftsForOwnerOptions): Promise<OwnedNftsResponse>;

// @public
export function getNftsForOwnerIterator(alchemy: Alchemy, owner: string, options?: GetBaseNftsForOwnerOptions): AsyncIterable<OwnedBaseNft>;

// @public
export function getNftsForOwnerIterator(alchemy: Alchemy, owner: string, options?: GetNftsForOwnerOptions): AsyncIterable<OwnedNft>;

// @public
export interface GetNftsForOwnerOptions {
    contractAddresses?: string[];
    // Warning: (ae-incompatible-release-tags) The symbol "excludeFilters" is marked as @public, but its signature references "NftExcludeFilters" which is marked as @beta
    excludeFilters?: NftExcludeFilters[];
    omitMetadata?: boolean;
    pageKey?: string;
}

// @beta
export function getOwnersForNft(alchemy: Alchemy, contractAddress: string, tokenId: number | string): Promise<GetOwnersForNftResponse>;

// @beta
export function getOwnersForNft(alchemy: Alchemy, nft: BaseNft): Promise<GetOwnersForNftResponse>;

// @public
export interface GetOwnersForNftResponse {
    readonly owners: string[];
}

// @public (undocumented)
export function getTokenBalances(alchemy: Alchemy, address: string, contractAddresses?: string[]): Promise<TokenBalancesResponse>;

// @public (undocumented)
export function getTokenMetadata(alchemy: Alchemy, address: string): Promise<TokenMetadataResponse>;

// @public (undocumented)
export function getTransactionReceipts(alchemy: Alchemy, params: TransactionReceiptsParams): Promise<TransactionReceiptsResponse>;

// @public
export function initializeAlchemy(config?: AlchemyConfig): Alchemy;

// @public
export function isHex(possibleHexString: string): boolean;

// @public
export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'silent';

// @public
export enum Network {
    // (undocumented)
    ARB_MAINNET = "arb-mainnet",
    // (undocumented)
    ARB_RINKEBY = "arb-rinkeby",
    // (undocumented)
    ETH_GOERLI = "eth-goerli",
    // (undocumented)
    ETH_KOVAN = "eth-kovan",
    // (undocumented)
    ETH_MAINNET = "eth-mainnet",
    // (undocumented)
    ETH_RINKEBY = "eth-rinkeby",
    // (undocumented)
    ETH_ROPSTEN = "eth-ropsten",
    // (undocumented)
    MATIC_MAINNET = "polygon-mainnet",
    // (undocumented)
    MATIC_MUMBAI = "polygon-mumbai",
    // (undocumented)
    OPT_KOVAN = "opt-kovan",
    // (undocumented)
    OPT_MAINNET = "opt-mainnet"
}

// @public
export class Nft extends BaseNft {
    readonly description: string;
    readonly media: TokenUri[];
    readonly metadataError: string | undefined;
    readonly rawMetadata: NftMetadata | undefined;
    readonly timeLastUpdated: string;
    readonly title: string;
    readonly tokenUri: TokenUri | undefined;
}

// @public
export interface NftContract {
    address: string;
}

// @beta
export enum NftExcludeFilters {
    SPAM = "SPAM"
}

// @public
export interface NftMetadata extends Record<string, any> {
    attributes?: Array<Record<string, any>>;
    background_color?: string;
    description?: string;
    external_url?: string;
    image?: string;
    name?: string;
}

// @public (undocumented)
export enum NftTokenType {
    // (undocumented)
    ERC1155 = "erc1155",
    // (undocumented)
    ERC721 = "erc721",
    // (undocumented)
    UNKNOWN = "unknown"
}

// @public
export interface OwnedBaseNft extends BaseNft {
    readonly balance: number;
}

// @public
export interface OwnedBaseNftsResponse {
    readonly ownedNfts: OwnedBaseNft[];
    readonly pageKey?: string;
    readonly totalCount: number;
}

// @public
export interface OwnedNft extends Nft {
    readonly balance: number;
}

// @public
export interface OwnedNftsResponse {
    readonly ownedNfts: OwnedNft[];
    readonly pageKey?: string;
    readonly totalCount: number;
}

// @public (undocumented)
export interface RawContract {
    // (undocumented)
    address: string | null;
    // (undocumented)
    decimal: string | null;
    // (undocumented)
    value: string | null;
}

// @public
export function setLogLevel(logLevel: LogLevel): void;

// @public
export function toHex(num: number): string;

// @public (undocumented)
export type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;

// @public (undocumented)
export interface TokenBalanceFailure {
    // (undocumented)
    contractAddress: string;
    // (undocumented)
    error: string;
    // (undocumented)
    tokenBalance: null;
}

// @public (undocumented)
export interface TokenBalancesResponse {
    // (undocumented)
    address: string;
    // (undocumented)
    tokenBalances: TokenBalance[];
}

// @public (undocumented)
export interface TokenBalanceSuccess {
    // (undocumented)
    contractAddress: string;
    // (undocumented)
    error: null;
    // (undocumented)
    tokenBalance: string;
}

// @public (undocumented)
export interface TokenMetadataResponse {
    // (undocumented)
    decimals: number | null;
    // (undocumented)
    logo: string | null;
    // (undocumented)
    name: string | null;
    // (undocumented)
    symbol: string | null;
}

// @public (undocumented)
export interface TokenUri {
    gateway: string;
    raw: string;
}

// @public (undocumented)
export interface TransactionReceiptsBlockHash {
    // (undocumented)
    blockHash: string;
}

// @public (undocumented)
export interface TransactionReceiptsBlockNumber {
    // (undocumented)
    blockNumber: string;
}

// @public (undocumented)
export type TransactionReceiptsParams = TransactionReceiptsBlockNumber | TransactionReceiptsBlockHash;

// @public (undocumented)
export interface TransactionReceiptsResponse {
    // (undocumented)
    receipts: TransactionReceipt[] | null;
}

// (No @packageDocumentation comment for this package)

```
